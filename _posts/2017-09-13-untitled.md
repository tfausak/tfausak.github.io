---
title: untitled
---

what are effects?
what does it mean to track them?
why bother tracking them?

for the purposes of this post, effects mean io actions
stuff like throwing exceptions, reading files, or making network requests
tracking them means using a type system to tag functions and values as having effects
tracking them allows us to be more confident in what code actually does

most languages do not track effects
for instance ocaml has `raise : exn -> 'a`
this means that we can throw exceptions in ocaml from anywhere
the type system does not keep track of its effect

some language coarsely track effects
for example haskell has `throwIO :: Exception e => e -> IO a`
this means the we can only throw exceptions from `IO` actions, which is `main`
the type system keeps track of the fact that throwing requires some effect

some languages finely track effects
for exaple purescript has `throw :: forall eff a. String -> Eff (exception :: EXCEPTION | eff) a`
this means that we can only throw exception from `Eff` actions that have the `EXCEPTION` capability
ultimately `main` has all capabilities by convention
the type system keeps track of which effects throwing requires

``` purescript
-- tldr
throw1 :: forall result . String -> result
throw2 :: forall result . String -> IO result
throw3 :: forall result . String -> Effect (exception :: Unit) result
```

to get a better understanding of these effect tracking systems, we are going to build them in purescript
purescript is a good language for this because it has a powerful type system but not many primitives
also it compiles to javascript which is broadly understandable by most programmers

---

we'll start with a version that doesn't track effects
nothing prevents you from writing purescript like ocaml!
it's just convention in the ecosystem that you have to deal with

our first version starts with the purescript code
we'll use the ffi to define our function
like the ocaml version it takes a string and returns anything

``` purescript
foreign import unsafeThrow :: forall result . String -> result
```

now we'll write the javascript side of the ffi
we'll export the function
it's a no-frills javascript function

``` javascript
module.exports = { unsafeThrow: function (message) { throw message } }
```

we could stop here
what would using this code look like?
any function could hide an effect

``` purescript
and :: Boolean -> Boolean -> Boolean
and x y = if x then y else unsafeThrow "exceptionally false!"
```

if we track effects then we can guarantee that some functions don't use any effects
we call those pure functions

---

so let's write the version that coarsely tracks effects
we'll need a few more building blocks
in particular we'll need a new type constructor for effectful values
i'm going to call it `IO` because that's what haskell uses
our new function will return an action rather than unit directly
we'll also define a type alias for a unit type that conveys no information
this is the easiest to work with in both purescript and javascript

``` purescript
type Unit = {}

type IO result = Unit -> result

throwIO :: forall result . String -> IO result
throwIO message = \ _ -> unsafeThrow message
```

note that we get to choose how to implement `IO`
it will delay execution by hiding it in a function that takes nothing interesting as its only argument

this gives us the know which functions are pure
if something doesn't have `IO` in the type, we know it can't throw any exceptions

``` purescript
-- doesn't compile!
and :: Boolean -> Boolean -> Boolean
and x y = if x then y else throwIO "exceptionally false!"
```

---

finally we'll write a version that finely tracks effects
this will let us say which effects a given action requires
so instead of things being either pure or impure,
they can be pure except for one effect (like throwing)

before we can do that, we need a way to track effects at the type level
purescript has row types, which is what its records are built with
so `{ key: "value" }` has type `{ key :: String }` -- that's a row
rows are also available at the type level
the type `{ key :: Unit }` has kind `(_ :: # Type)`
where `#` means "row"

``` purescript
type Effect (effects :: # Type) result = IO result
```

with that in place we can define the version that finely tracks effects
it adds some information on the type level
but the actual implementation doesn't change at all.

``` purescript
throwEffect :: forall result . String -> Effect (exception :: Unit) result
throwEffect = throwIO
```

again, why bother doing all this?
let's say that we want to make sure some chunk of code doesn't use `throw`
with the previous two versions, we can't prove that to the type system
with this version, we can

``` purescript
-- still doesn't compile!
and :: Boolean -> Boolean -> Boolean
and x y = if x then y else throwEffect "exceptionally false!"
```
