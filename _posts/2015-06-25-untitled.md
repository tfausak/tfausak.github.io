---
title: untitled
---

- i started looking at frege
- <https://github.com/Frege/frege>
- pronounced "free-guh"
- made a simple example project
- <https://github.com/tfausak/fregexample>
- uses leiningen ("line-ing-in")
- ported an existing haskell program
- <https://github.com/tfausak/fr2048>
- it was mostly painless
- looked at java interop
- <https://gist.github.com/tfausak/c7c88bcc08006a1190ca>
- probably about as good as it can be
- really highlights the mutability of java
- and that means everything in frege ends up in the io monad
- i wanted to highlight some differences between haskell and frege
- <https://github.com/Frege/frege/wiki/Differences-between-Frege-and-Haskell>

- imports are nicer
  - `import Foo as Foo (Foo)` in particular
- differences in prelude are annoying
  - like `floor` and `ceiling` are in `Prelude.Math`
- also syntactic differences get annoying when porting code
  - every module has to start with `module Foo where`
  - modules cannot be empty
  - no `deriving` stuff, instead separate `derive Class Record` statements
- standard library is mostly all there
  - lack of `read` is killer
- basically no libraries
- standard library documentation is good
  - <http://www.frege-lang.org/doc/frege/Prelude.html>
- no build tool in frege
  - but works fine with lein
  - and probably maven and ant, but i can't speak to that
- no package site like hackage or rubygems
- records are way better
  - namespaced, so can have multiple per module
  - easy to read, write, and update
  - no lenses required!
  - `data R = R { x :: String }; v = R { x = "..." }; v.x = "..."; v.x`
- string escape sequences are different
  - `"\ESC"` -> `"\u001b"`
  - they are the same as java
- string isn't `[Char]`, which gets annoying
  - feels like `String` should really be `Text`
  - especially considering `packed`/`unpacked` are similar to `Data.Text.pack`/`unpack`
- distributing an uberjar is nice
  - but so is distributing an executable
- hard to tell if build times are bad, considering JVM startup time
- repl is a separate project entirely
  - that being said, fx repl is pretty cool
- doc comments part of grammar
  - `---` and `{--`
- booleans are lowercase
- multi-arg lambas are more annoying
  - `\x \y -> (x, y)`
  - understandable, since that's really a shortcut for `\x -> \y -> (x, y)`
- `@` behaves differently
  - `f x@(y:ys)` is now `f (x@(y:ys))`
- public vs private is handled with `private` modifier instead of export list
  - i like this
  - i don't like how you have to mark both the type and implementation as private
  - `private f :: a -> b; private f x = ...`
